<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractide.xyz - Single Player Demo</title>
    <style>
        body { margin: 0; background: #222; color: #fff; font-family: Arial, sans-serif; }
        #gameCanvas { background: #333; display: block; margin: 0 auto; }
        #ui { position: absolute; top: 10px; left: 10px; }
        #restart { position: absolute; top: 10px; right: 10px; padding: 5px 10px; background: #444; border: 1px solid #666; color: #fff; cursor: pointer; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui">
        <p id="size">Size: 1</p>
        <p id="skills">Skills: None</p>
        <p id="fragments">Fragments: Energy: 0, Skill: 0, Structure: 0</p>
    </div>
    <button id="restart">Restart</button>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiSize = document.getElementById('size');
        const uiSkills = document.getElementById('skills');
        const uiFragments = document.getElementById('fragments');
        const restartBtn = document.getElementById('restart');

        // Game constants
        const GAME_WIDTH = 2000;
        const GAME_HEIGHT = 2000;
        const BASE_SPEED = 5;
        const FRAGMENT_COUNT = 100; // Initial fragments
        const FRAGMENT_RESPAWN_INTERVAL = 1000; // ms to respawn new fragments

        // Player
        let player = {
            x: GAME_WIDTH / 2,
            y: GAME_HEIGHT / 2,
            size: 1,
            skills: [],
            energyFragments: 0,
            skillFragments: 0,
            structureFragments: 0,
            armor: 0,
            satellites: []
        };

        // Fragments array
        let fragments = [];

        // Camera (for following player)
        let cameraX = 0;
        let cameraY = 0;

        // Mouse position for movement
        let mouseX = canvas.width / 2;
        let mouseY = canvas.height / 2;

        // Game state
        let isGameOver = false;

        // Skills tree (simple random for demo)
        const skillTrees = [
            { id: 'A', name: 'Defense', skills: ['shield', 'regen'] },
            { id: 'B', name: 'Offense', skills: ['dash', 'split'] },
            { id: 'C', name: 'Control', skills: ['magnet', 'slow'] }
        ];
        let currentTree = skillTrees[Math.floor(Math.random() * skillTrees.length)];

        function initGame() {
            player = {
                x: Math.random() * GAME_WIDTH,
                y: Math.random() * GAME_HEIGHT,
                size: 1,
                skills: [],
                energyFragments: 0,
                skillFragments: 0,
                structureFragments: 0,
                armor: 0,
                satellites: []
            };
            fragments = [];
            isGameOver = false;
            currentTree = skillTrees[Math.floor(Math.random() * skillTrees.length)];
            generateFragments(FRAGMENT_COUNT);
            updateUI();
        }

        function generateFragments(count) {
            for (let i = 0; i < count; i++) {
                const typeRoll = Math.random();
                let type = 'energy';
                if (typeRoll > 0.7 && typeRoll <= 0.9) type = 'skill';
                else if (typeRoll > 0.9) type = 'structure';

                fragments.push({
                    x: Math.random() * GAME_WIDTH,
                    y: Math.random() * GAME_HEIGHT,
                    type: type,
                    value: 1 // Simple value for demo
                });
            }
        }

        function updateUI() {
            uiSize.textContent = `Size: ${player.size.toFixed(1)}`;
            uiSkills.textContent = `Skills: ${player.skills.join(', ') || 'None'}`;
            uiFragments.textContent = `Fragments: Energy: ${player.energyFragments}, Skill: ${player.skillFragments}, Structure: ${player.structureFragments}`;
        }

        // Handle movement towards mouse
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        // Touch support for mobile
        canvas.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            mouseX = touch.clientX - rect.left;
            mouseY = touch.clientY - rect.top;
            e.preventDefault();
        });

        // Skill use (space key for demo - uses first skill)
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ' && player.skills.length > 0 && !isGameOver) {
                useSkill(player.skills[0]);
            }
        });

        function useSkill(skill) {
            if (skill === 'dash') {
                // Simple dash forward
                const dx = mouseX - canvas.width / 2;
                const dy = mouseY - canvas.height / 2;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    player.x += (dx / dist) * 100;
                    player.y += (dy / dist) * 100;
                }
            }
            // Add more skill logics as needed
        }

        // Restart button
        restartBtn.addEventListener('click', initGame);

        // Game loop
        function gameLoop() {
            if (isGameOver) return;

            // Movement
            const dx = mouseX - canvas.width / 2;
            const dy = mouseY - canvas.height / 2;
            const dist = Math.hypot(dx, dy);
            if (dist > 0) {
                const speed = BASE_SPEED / Math.sqrt(player.size);
                player.x += (dx / dist) * speed;
                player.y += (dy / dist) * speed;
            }

            // Boundaries
            player.x = Math.max(0, Math.min(GAME_WIDTH, player.x));
            player.y = Math.max(0, Math.min(GAME_HEIGHT, player.y));

            // Collect fragments
            fragments = fragments.filter(frag => {
                const fragDist = Math.hypot(player.x - frag.x, player.y - frag.y);
                if (fragDist < player.size * 10) { // Collect radius based on size
                    if (frag.type === 'energy') {
                        player.energyFragments += frag.value;
                        // Use energy to grow (demo: auto-grow)
                        player.size += frag.value * 0.1;
                    } else if (frag.type === 'skill') {
                        player.skillFragments += frag.value;
                        // Unlock skill if enough (demo: unlock next in tree)
                        if (player.skills.length < currentTree.skills.length) {
                            player.skills.push(currentTree.skills[player.skills.length]);
                        }
                    } else if (frag.type === 'structure') {
                        player.structureFragments += frag.value;
                        // Use for armor (demo: add armor)
                        player.armor += frag.value;
                    }
                    updateUI();
                    return false;
                }
                return true;
            });

            // Camera follow player
            cameraX = player.x - canvas.width / 2;
            cameraY = player.y - canvas.height / 2;
            cameraX = Math.max(0, Math.min(GAME_WIDTH - canvas.width, cameraX));
            cameraY = Math.max(0, Math.min(GAME_HEIGHT - canvas.height, cameraY));

            // Render
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Render fragments
            fragments.forEach(frag => {
                ctx.beginPath();
                const screenX = frag.x - cameraX;
                const screenY = frag.y - cameraY;
                ctx.arc(screenX, screenY, 5, 0, Math.PI * 2);
                ctx.fillStyle = frag.type === 'energy' ? 'blue' : (frag.type === 'skill' ? 'green' : 'yellow');
                ctx.fill();
            });

            // Render player
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, player.size * 10, 0, Math.PI * 2);
            ctx.fillStyle = 'red';
            ctx.fill();

            // Simple "game over" if size too big (demo purpose)
            if (player.size > 50) {
                isGameOver = true;
                alert('You grew too big! Game Over. Restart to play again.');
            }

            requestAnimationFrame(gameLoop);
        }

        // Periodic fragment respawn
        setInterval(() => {
            if (!isGameOver) generateFragments(10);
        }, FRAGMENT_RESPAWN_INTERVAL);

        initGame();
        gameLoop();
    </script>
</body>
</html>
